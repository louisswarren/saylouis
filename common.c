#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>

#include <monocypher.h>

#include "common.h"

static const uint32_t kdf_blocks = 512 * 1024;
static const uint32_t kdf_iterations = 3;
static const uint8_t kdf_salt[16] = {
	/* Generated by fair dice roll. Guaranteed to be random. */
	0x77, 0xe4, 0xd7, 0x76, 0xc5, 0xe1, 0x0e, 0xd8,
	0x09, 0xfa, 0xb5, 0x74, 0xd6, 0x3c, 0xd4, 0xfc
};

void key_derive(uint8_t key[32], const uint8_t *buf, uint32_t buflen)
{
	void *work_area = calloc(kdf_blocks, 1024);
	if (!work_area)
		die("Failed to allocate work area");

	crypto_argon2i(
		key, 32,
		work_area,
		kdf_blocks, kdf_iterations,
		buf, buflen,
		kdf_salt, sizeof(kdf_salt)
	);
}

void key_exchange(
	uint8_t shared[32],
	const uint8_t other[32],
	const uint8_t public[32],
	const uint8_t secret[32]
) {
	crypto_blake2b_ctx bc;

	/* Generate a raw shared secret */
	crypto_x25519(shared, secret, other);

	/* Hash the shared secret with the public keys */
	crypto_blake2b_general_init(&bc, 32, NULL, 0);
	crypto_blake2b_update(&bc, shared, 32);
	for (int i = 0; i < 32; ++i) {
		uint8_t x = other[i] ^ public[i];
		crypto_blake2b_update(&bc, &x, 1);
	}
	crypto_blake2b_final(&bc, shared);
}

void
nonce_inc(uint8_t nonce[24])
{
	for (int i = 0; i < 24 && ++nonce[i] == 0; ++i);
}

void
show_fingerprint(const uint8_t public[32])
{
	for (int i = 0; i < 32; ++i)
		fprintf(stderr, "%x", public[i]);
	fprintf(stderr, "\n");
}

static
int
set_no_echo(struct termios *prev)
{
	struct termios term_noecho;
	if (tcgetattr(0, prev))
		return 1;
	term_noecho = *prev;
	term_noecho.c_lflag &= (tcflag_t)~ECHO;
	if (tcsetattr(0, TCSAFLUSH, &term_noecho))
		return 1;
	return 0;
}

uint32_t
read_password(uint8_t *buf, uint32_t bufsize, const char *ttypath)
{
	uint32_t password_len = 0;
	struct termios term_old;
	FILE *tty = fopen(ttypath, "r");

	if (!tty)
		die("Failed to get a password from %s\n", ttypath);

	if (set_no_echo(&term_old)) {
		buf = fgets(buf, (int)bufsize, tty);
	} else {
		fprintf(stderr, "Passphrase (Echo off): ");
		buf = fgets(buf, (int)bufsize, tty);
		(void)tcsetattr(0, TCSAFLUSH, &term_old);
	}
	fclose(tty);

	if (!buf)
		die("Failed to read password.\n");

	password_len = (uint32_t)strlen(buf);

	if (password_len + 1 == bufsize)
		die("Password was truncated.\n");

	if (password_len && buf[password_len - 1] == '\n')
		buf[password_len-- - 1] = '\0';

	if (!password_len)
		die("Password was empty.\n");

	return password_len;
}
